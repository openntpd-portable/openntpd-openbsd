#!/bin/sh -
#
# THIS FILE AUTOMATICALLY GENERATED.  DO NOT EDIT.
# generated from:
#
#	OpenBSD: etc.vax/MAKEDEV.md,v 1.4 2002/02/14 14:32:26 todd Exp 
#	OpenBSD: MAKEDEV.mi,v 1.30 2002/02/14 14:32:26 todd Exp 
#	OpenBSD: MAKEDEV.sub,v 1.6 2002/02/14 05:50:37 todd Exp 
#
#	$OpenBSD: MAKEDEV,v 1.39 2002/02/14 14:32:50 todd Exp $
#
# Copyright (c) 2001 Todd T. Fries <todd@OpenBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
# THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#


# Device "make" file.  Valid arguments:
#	all	makes all known devices, including local devices.
#		Tries to make the ``standard'' number of each type.
#	std	standard devices
#	local	configuration specific devices
# Tapes:
#	st*	SCSI tapes
#	mt*	(Magnetic) 9-track reel tape
#	ht*	massbus tm03 & tu??
#	tm*	unibus tm11 & te10 emulations (e.g. Emulex tc-11)
#	ts*	unibus ts11
#	ut*	unibus tu45 emulations (e.g.si 9700)
# Disks:
#	hp*	massbuss rm??
#	hk*	unibus rk06 and rk07
#	up*	other unibus devices (e.g. on Emulex sc-21v controller)
#	ra*	MSCP disks (ra??, hd??)
#	rb*	730 idc w/ rb80 and/or rb02
#	rx*	MSCP floppy disk (rx33/50/...)
#	rl*	unibus r102
#	hd*	HP300 HP-IB disks
#	sd*	SCSI disks
#	cd*	SCSI cdrom drives
#	ch*	SCSI media changer
#	ss*	SCSI scanners
#	uk*	SCSI Unknown device
#	xy*	Xylogic 450/451 disks
#	rd*	"ramdisk" pseudo-disks
#	xd*	Xylogic 753/7053 disks
#	fd*	Floppy disk drives (3 1/2", 5 1/4")
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk devices
# Pseudo terminals:
#	tty*	set of 16 slave psuedo terminals
#	pty*	set of 16 master pseudo terminals
# Printers:
# Terminal ports:
#	dhu*	unibus dhu11
#	dh*	unibus dh11 and emulations (e.g. Able dmax, Emulex cs-11)
#	dmf*	unibus dmf32
#	dmz*	unibus dmz32
#	vt*	console
#	dz*	unibus dz11 and dz32
# Special purpose devices:
#	audio*	audio device
#	openprom	
#	bpf*	Berkeley Packet Filter
#	pf*	Packet Filter
#	altq/	ALTQ control interface
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	*random	inkernel random data source
#	magma*	magma card (makes 16 tty and 2 bpp)
#	xfs*	XFS filesystem devices
#	raid*	RAIDframe disk devices
#	fd	makes fd/* for the fdescfs
#	ses*	SES/SAF-TE SCSI devices
PATH=/sbin:/usr/sbin:/bin:/usr/bin
T=$0

# set this to echo for Echo-Only debugging
[ "$eo" ] || eo=

hex()
{
	case $1 in
	[0-9]) echo -n $1;;
	10) echo -n a;;
	11) echo -n b;;
	12) echo -n c;;
	13) echo -n d;;
	14) echo -n e;;
	15) echo -n f;;
	esac
}

trunc()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg1="$1"
	arg2="$2"
	case $3 in
	l)   echo ${arg2#$arg1} ;;
	r|*) echo ${arg1#$arg2} ;;
	esac
}

unt()
{
	# XXX pdksh can't seem to deal with locally scoped variables
	# in ${foo#$bar} expansions
	arg="$1"
	tmp="${arg#[a-zA-Z]*}"
	tmp="${tmp%*[a-zA-Z]}"
	while [ "$tmp" != "$arg" ]
	do
		arg=$tmp
		tmp="${arg#[a-zA-Z]*}"
		tmp="${tmp%*[a-zA-Z]}"
	done
	echo $arg
}

dodisk()
{
	[ "$DEBUG" ] && set -x
	n=$(($((${5}*${7:-16}))+${6})) count=0
	RMlist="$RMlist $1$2? r$1$2?"
	[ 0$7 -ne 8 ] && l="i j k l m n o p"
	for d in a b c d e f g h $l
	do
		M $1$2$d	b $3 $(($n+$count)) 640
		M r$1$2$d	c $4 $(($n+$count)) 640
		let count=count+1
	done
	MKlist="$MKlist;chown root.operator $1$2? r$1$2?"
}

dodisk2()
{
	n=$(($(($5*${7:-16}))+$6))
	M $1$2a b $3 $n 640 operator
	M r$1$2a c $4 $n 640 operator
	n=$(($n+2))
	M $1$2c b $3 $n 640 operator
	M r$1$2c c $4 $n 640 operator
}

# M name b/c major minor [mode] [group]
RMlist="rm -f"
MKlist=":"

mkl() {
	[ "${mklist[$1]}" ] && {
		mklist[$1]="${mklist[$1]};mknod -m $1 $2 $3 $4 $5"
	} || {
		mklist[$1]="mknod -m $1 $2 $3 $4 $5"
		modes="$modes $1"
	}
}

M() {
	RMlist="$RMlist $1"
	mkl ${5-666} $1 $2 $3 $4
	mklist="$mklist $1"
	G=${6:-wheel}
	[ "$7" ] && {
		MKlist="$MKlist;chown $7.$G $1"
	} || {
		case $G in
		wheel)g=0;;kmem)g=2;;operator)g=5;;tty)g=4;;dialer)g=117;;
		esac
		[ "${grplist[$g]}" ] && {
			grplist[$g]="${grplist[$g]} $1"
		} || {
			groups="$groups $g"
			grplist[$g]="chgrp $G $1"
		}
	}
	return 0
}

R() {
[ "$DEBUG" ] && set -x
for i in "$@"
do
U=`unt $i`
[ "$U" ] || U=0

case $i in
ramdisk)
	R std random
	R fd0 sd0 sd1 rd0
	;;

std)
	M console	c 0 0 600
	M tty		c 2 0
	M mem		c 3 0 640 kmem
	M kmem		c 3 1 640 kmem
	M null		c 3 2
	M zero		c 3 12
	M stdin		c 53 0
	M stdout	c 53 1
	M stderr	c 53 2
	M ksyms		c 50 0 640 kmem
	M drum		c 7 0 640 kmem
	M klog		c 33 0 600
	M ttyg0		c 25 0
	M ttyg1		c 25 1
	M ttyg2		c 25 2
	M ttyg3		c 25 3
	M crl		c 35 0
	M csa1		c 51 0 600
	M csa2		c 51 1 600
	M tu0		b 8 0
	M tu1		b 8 1
	M kUmem		c 3 3 660
	;;

ht*|tm*|mt*|ts*|ut*)
	case $i in
	ht*) n=ht b=1 c=5;;
	mt*) n=mt b=15 c=38;;
	tm*) n=tm b=5 c=14;;
	ts*) n=ts b=6 c=16;;
	ut*) n=ut b=10 c=17;;
	esac
	case $U in
	[0-7])
		four=$(($U+4)) eight=$(($U+8))
		twelve=$(($U+12)) twenty=$(($U+20))
		M $n$U		b $b $U	660 operator
		M $n$four	b $b $four	660 operator
		M $n$eight	b $b $eight	660 operator
		M $n$twelve	b $b $twelve	660 operator
		M n$n$four	b $b $four	660 operator
		M n$n$twelve	b $b $twelve	660 operator
		M nr$n$four	c $c $four	660 operator
		M nr$n$twelve	c $c $twelve	660 operator
		M r$n$U		c $c $U		660 operator
		M r$n$four	c $c $four	660 operator
		M r$n$eight	c $c $eight	660 operator
		M r$n$twelve	c $c $twelve	660 operator
		if [ $i = ut ]; : XXXX
		then
			M $n$twenty	b $b $twenty 660 operator
			M r$n$twenty	c $b $twenty 660 operator
		fi
		#RMlist="$RMlist mt$U mt$four mt$eight mt$twelve"
		#RMlist="$RMlist nmt$U nmt$eight nrmt$eight"
		#RMlist="$RMlist nrmt$unit nrmt$eight"
		#RMlist="$RMlist rmt$unit rmt$four rmt$eight rmt$twelve"
		;;
	*)
		echo bad unit for tape in: $i
		;;
	esac
	umask 77
	;;

ses*)
	M ses$U c 124 $U 640 operator
	;;

fd)
	RMlist="mkdir -p fd;$RMlist" n=0
	while [ $n -lt 64 ];do M fd/$n c 53 $n;n=$(($n+1));done
	MKlist="$MKlist;chmod 555 fd"
	;;

xfs*)
	M xfs$U c 51 $U 600
	;;

magma*)
	case $U in
	0)	offset=0  nam=m;;
	1)	offset=16 nam=n;;
	2)	offset=32 nam=o;;
	*)	echo "bad unit for $i: $U"; exit 127;;
	esac
	offset=$(($U*64))
	n=0
	while [ $n -lt 16 ]
	do
		name=${nam}`hex $n`
		M tty$name c major_mag_c $(($offset+$n)) 660 dialer uucp
		n=$(($n+1))
	done
	M bpp${nam}0 c major_bppmag_c $(($offset+0)) 600
	M bpp${nam}1 c major_bppmag_c $(($offset+1)) 600
	;;

*random)
	n=0
	for pre in " " s u p a
	do
		M ${pre}random c 67 $n 644
		n=$(($n+1))
	done
	;;

tun*)
	M tun$U c 57 $U 600
	;;

lkm)
	M lkm c 28 0 640 kmem
	;;

altq)
	RMlist="mkdir -p altq;$RMlist"
	for d in altq cbq wfq afm fifoq red rio localq hfsc cdnr blue priq; do
		M altq/$d c 75 $U 644
		U=$(($U+1))
	done
	;;

pf*)
	M pf c 42 0 600
	;;

bpf*)
	M bpf$U c 56 $U 600
	;;

openprom)
	M openprom c 70 0  
	;;

audio*)
	M sound$U	c 69 $U
	M mixer$U	c 69 $(($U+16))
	M audio$U	c 69 $(($U+128))
	M audioctl$U	c 69 $(($U+192))
	MKlist="$MKlist;[ -e audio ] || ln -s audio$U audio"
	MKlist="$MKlist;[ -e mixer ] || ln -s mixer$U mixer"
	MKlist="$MKlist;[ -e sound ] || ln -s sound$U sound"
	MKlist="$MKlist;[ -e audioctl ] || ln -s audioctl$U audioctl"
	;;

dz*)
	unit=${i#dz};
       case $unit in
       [0-7])
	       i=0
	       while [ $i -lt 8 ]; do
		       no=$(($unit * 8 + $i))
		       if [ $no -lt 10 ]; then
			       no="0${no}"
		       fi
		       rm -f tty${no}
		       mknod tty${no} c 1 $no
		       i=$(($i + 1))
	       done
	       ;;
	*)
	       echo bad unit for dz in: $i
	       ;;
       esac
	;;

dhu*|dmz*|dmf*|dh*)
	set -A cnvtbl 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v
	case $i in
	vt*)    name=vt; major=68; count=8;
		unit=${i#vt}
		case $unit in
		0) ch=w ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmz*)   name=dmz; major=37; count=24;
		unit=${i#dmz}
		case $unit in
		0) ch=a ;; 1) ch=b ;; 2) ch=c ;; 3) ch=e ;; 4) ch=f ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dmf*)   name=dmf; major=22; count=8;
		unit=${i#dmf}
		case $unit in
		0) ch=A ;; 1) ch=B ;; 2) ch=C ;; 3) ch=E ;;
		4) ch=F ;; 5) ch=G ;; 6) ch=H ;; 7) ch=I ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dhu*)   name=dhu; major=34; count=16;
		unit=${i#dhu}
		case $unit in
		0) ch=S ;; 1) ch=T ;; 2) ch=U ;; 3) ch=V ;;
		4) ch=W ;; 5) ch=X ;; 6) ch=Y ;; 7) ch=Z ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	dh*)    name=dh; major=12; count=16;
		unit=${i#dh}
		case $unit in
		0) ch=h ;; 1) ch=i ;; 2) ch=j ;; 3) ch=k ;;
		4) ch=l ;; 5) ch=m ;; 6) ch=n ;; 7) ch=o ;;
		*) echo bad unit for $name in: $i ;;
		esac;;
	esac
	i=0
	while [ $i -lt $count ]; do
		let=${cnvtbl[$i]}
		if [ -n "$let" ] ;then
			rm -f tty${ch}${let}
			mknod tty${ch}${let} c $major $(($unit * $count + $i))
		else
			echo bad count for ${name}: $unit, $count, $i
		fi
		i=$(($i + 1))
	done
	;;

dl*)
	unit=${i#dl}
	major=66
	let=${cnvtbl[$unit]}
	if [ -n "$let" ] ;then
		rm -f ttyJ${let}
		mknod ttyJ${let} c $major $unit
	else
		echo bad number for ${name}: $unit
	fi
	;;

pty*)
	case $U in
	0) off=0 name=p;;
	1) off=16 name=q;;
	2) off=32 name=r;;
	3) off=48 name=s;;
	4) off=64 name=t;;
	5) off=80 name=u;;
	6) off=96 name=v;;
	7) off=112 name=w;;
	8) off=128 name=x;;
	9) off=144 name=y;;
	10) off=160 name=z;;
	11) off=176 name=P;;
	12) off=192 name=Q;;
	13) off=206 name=R;;
	14) off=224 name=S;;
	15) off=240 name=T;;
	*) echo bad unit for pty in: $i; continue;;
	esac
	n=0
	while [ $n -lt 16 ]
	do
		nam=$name$(hex $n)
		M tty$nam c 20 $(($off+$n))
		M pty$nam c 21 $(($off+$n))
		n=$(($n+1))
	done
	;;

vnd*)
	dodisk vnd $U 18 55 $U 0
	dodisk svnd $U 18 55 $U 128
	;;

fd*)
	typnam=$U${i#fd[01]*}
	case $typnam in
	0|1)	typnum=0;; # no type specified, assume A
	*A)	typnum=0; typnam=0;;
	*B)	typnum=1;;
	*C)	typnum=2;;
	*D)	typnum=3;;
	*E)	typnum=4;;
	*F)	typnum=5;;
	*G)	typnum=6;;
	*H)	typnum=7;;
	*)	echo bad type $typnam for $i; exit 1;;
	esac
	case $U in
	0|1)	blk=16; chr=54;;
	*)	echo bad unit $U for $i; exit 1;;
	esac
	nam=fd${typnam}
	n=$(($(($U*128))+$(($typnum*16))))
	M ${nam}a	b $blk $n 640 operator
	M ${nam}b	b $blk $(($n+1)) 640 operator
	M ${nam}c	b $blk $(($n+2)) 640 operator
	M r${nam}a	c $chr $n 640 operator
	M r${nam}b	c $chr $(($n+1)) 640 operator
	M r${nam}c	c $chr $(($n+2)) 640 operator
	;;

rd*)
	dodisk2 rd $U 23 106 $U 0
	;;

uk*)
	M uk$U c 65 $U 640 operator
	;;

ss*)
	M ss$U c 64 $U 440 operator
	RMlist="$RMlist scan$U"
	MKlist="$MKlist;umask 77;ln -s ss$U scan$U"
	;;

ch*)
	M ch$U c 63 $U 660 operator
	;;

cd*)
	dodisk2 cd $U 22 61 $U 0
	;;

st*)
	n=$(($U*16))
	for pre in " " n e en
	do
		M ${pre}st$U	b 21 $n 660 operator
		M ${pre}rst$U	c 38 $n 660 operator
		n=$(($n+1))
	done
	;;

local)
	test -s $T.local && sh $T.local
	;;

all)
	R dz0 dh0 dmf0 dmz0 dhu0 mt0 hd0 hd1 hd2 audio0 xfs0 ss0 ss1
	R uk0 ses0 rndrandom lkm pf altq tun0 tun1 tun2 tun3 bpf0 bpf1
	R bpf2 bpf3 bpf4 bpf5 bpf6 bpf7 bpf8 bpf9 fd1 fd1B fd1C fd1D
	R fd1E fd1F fd1G fd1H fd0 fd0B fd0C fd0D fd0E fd0F fd0G fd0H
	R xd0 xd1 xd2 xd3 xy0 xy1 xy2 xy3 ut0 up0 up1 up2 up3 ts0 tm0
	R rx0 rx1 rl0 rl1 rl2 rl3 rb0 rb1 rb2 rb3 ra0 ra1 ra2 ra3 ht0
	R hp0 hp1 hp2 hp3 hk0 hk1 hk2 hk3 rd0 raid0 raid1 raid2 raid3
	R ccd0 ccd1 ccd2 ccd3 vnd0 vnd1 vnd2 vnd3 std cd0 cd1 ch0 st0
	R st1 pty0 pty1 pty2 fd sd0 sd1 sd2 sd3 sd4
	;;

up*|xd*|xy*|sd*|rx*|rl*|rb*|raid*|ra*|hp*|hk*|hd*|ccd*)
	case $i in
	up*) dodisk up $U 2 13 $U 0;;
	xd*) dodisk xd $U 10 42 $U 0;;
	xy*) dodisk xy $U 3 9 $U 0;;
	sd*) dodisk sd $U 20 59 $U 0;;
	rx*) dodisk rx $U 12 30 $U 0;;
	rl*) dodisk rl $U 14 32 $U 0;;
	rb*) dodisk rb $U 11 23 $U 0;;
	raid*) dodisk raid $U 25 73 $U 0;;
	ra*) dodisk ra $U 9 9 $U 0;;
	hp*) dodisk hp $U 0 4 $U 0;;
	hk*) dodisk hk $U 3 11 $U 0;;
	hd*) dodisk hd $U 19 58 $U 0;;
	ccd*) dodisk ccd $U 17 54 $U 0;;
	esac
	;;

*)
	echo $i: unknown device
	;;
esac
done
}
R "$@"
if [ "$os" = "SunOS" ]; then
	eo=transform
	transform() {
		case $mode in
		600) mask=077;;
		640) mask=027;;
		660) mask=007;;
		644) mask=022;;
		666) mask=0;;
		440) mask=227;;
		esac
		echo `echo "$@"|sed \
		    's/mknod -m \([0-9]*\) /umask '$mask';mknod /;s/-m [0-9]* //g;\
		    s/operator/5/g;s/root.kmem/root.2/g;s/root\./root:/g'`
	}
fi
list="$RMlist"
for mode in $modes; do
	list="$list;${mklist[$mode]}"
done
for group in $groups; do
	list="$list;${grplist[$group]}"
done
list="$list;$MKlist"
if [ "$eo" = "echo" -o "$eo" = "transform" ]; then
	$eo "$list"
else
	echo "$list" | sh
fi
