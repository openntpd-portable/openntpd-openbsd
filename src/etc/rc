#	$OpenBSD: rc,v 1.191 2002/02/19 02:21:16 deraadt Exp $

# System startup script run by init on autoboot
# or after single-user.
# Output and error are redirected to console by init,
# and the console is the controlling terminal.

# Subroutines (have to come first).

# Strip comments (and leading/trailing whitespace if IFS is set)
# from a file and spew to stdout
stripcom() {
	local _file="$1"
	local _line

	{
		while read _line ; do
			_line=${_line%%#*}		# strip comments
			test -z "$_line" && continue
			echo $_line
		done
	} < $_file
}

# End subroutines

stty status '^T'

# Set shell to ignore SIGINT (2), but not children;
# shell catches SIGQUIT (3) and returns to single user after fsck.
trap : 2
trap : 3	# shouldn't be needed

HOME=/; export HOME
PATH=/sbin:/bin:/usr/sbin:/usr/bin
export PATH

if [ $1x = shutdownx ]; then
	dd if=/dev/urandom of=/var/db/host.random bs=1024 count=64 >/dev/null 2>&1
	chmod 600 /var/db/host.random >/dev/null 2>&1
	if [ $? -eq 0 -a -f /etc/rc.shutdown ]; then
		echo /etc/rc.shutdown in progress...
		. /etc/rc.shutdown
		echo /etc/rc.shutdown complete.
		if [ "X${powerdown}" = X"YES" ]; then
			exit 2
		fi
	else
		echo single user: not running /etc/rc.shutdown
	fi
	exit 0
fi

# Configure ccd devices.
if [ -f /etc/ccd.conf ]; then
	ccdconfig -C
fi

# Configure raid devices.
for dev in 0 1 2 3; do
	if [ -f /etc/raid$dev.conf ]; then
		raidctl -c /etc/raid$dev.conf raid$dev
	fi
done

# Check parity on raid devices.
raidctl -P all

swapctl -A -t blk

if [ -e /fastboot ]; then
	echo "Fast boot: skipping disk checks."
elif [ $1x = autobootx ]; then
	echo "Automatic boot in progress: starting file system checks."
	fsck -p
	case $? in
	0)
		;;
	2)
		exit 1
		;;
	4)
		echo "Rebooting..."
		reboot
		echo "Reboot failed; help!"
		exit 1
		;;
	8)
		echo "Automatic file system check failed; help!"
		exit 1
		;;
	12)
		echo "Boot interrupted."
		exit 1
		;;
	130)
		# interrupt before catcher installed
		exit 1
		;;
	*)
		echo "Unknown error; help!"
		exit 1
		;;
	esac
fi

trap "echo 'Boot interrupted.'; exit 1" 3

umount -a >/dev/null 2>&1
mount -a -t nonfs
mount -uw /		# root on nfs requires this, others aren't hurt
rm -f /fastboot		# XXX (root now writeable)

# pick up option configuration
. /etc/rc.conf

# set flags on ttys.  (do early, in case they use tty for SLIP in netstart)
echo 'setting tty flags'
ttyflags -a

if [ "X${pf}" != X"NO" ]; then
	RULES="block in all\nblock out all"
	case `sysctl vfs.mounts.nfs` in
	*[1-9]*)
		# don't kill NFS
		RULES="$RULES\npass in proto udp from any port { 111, 2049 } to any"
		RULES="$RULES\npass out proto udp from any to any port { 111, 2049 }"
		;;
	esac
	echo $RULES | pfctl -R - -e
fi

if [ -f /etc/sysctl.conf ]; then
(
	# delete comments and blank lines
	set -- `stripcom /etc/sysctl.conf`
	while [ $# -ge 1 ] ; do
		sysctl -w $1
		shift
	done
)
fi

# set hostname, turn on network
echo 'starting network'
. /etc/netstart

if [ "X${pf}" != X"NO" ]; then
	if [ -f ${nat_rules} ]; then
		pfctl -N ${nat_rules}
	fi
	if [ -f ${pf_rules} ]; then
		pfctl -R ${pf_rules}
	fi
fi

mount /usr >/dev/null 2>&1
mount /var >/dev/null 2>&1

# if there's no /var/db/host.random, make one through /dev/urandom
if [ ! -f /var/db/host.random ]; then
	dd if=/dev/urandom of=/var/db/host.random bs=1024 count=64 \
		>/dev/null 2>&1
	chmod 600 /var/db/host.random >/dev/null 2>&1
else
	dd if=/var/db/host.random of=/dev/urandom bs=1024 count=64 \
	    > /dev/null 2>&1
	dd if=/var/db/host.random of=/dev/arandom bs=1024 count=64 \
	    > /dev/null 2>&1
fi

# reset seed file, so that if a shutdown-less reboot occurs,
# the next seed is not a repeat
dd if=/dev/urandom of=/var/db/host.random bs=1024 count=64 \
    > /dev/null 2>&1

# clean up left-over files
rm -f /etc/nologin
rm -f /var/spool/lock/LCK.*
rm -f /var/spool/uucp/STST/*
(cd /var/run && { rm -rf -- *; install -c -m 664 -g utmp /dev/null utmp; })

# save a copy of the boot messages
dmesg >/var/run/dmesg.boot

echo 'starting system logger'
rm -f /dev/log
if [ "X${named_flags}" != X"NO" -a "X${named_chroot}" != "X" ]; then
	rm -f ${named_chroot}/dev/log
	syslogd_flags="${syslogd_flags} -a ${named_chroot}/dev/log"
fi
syslogd ${syslogd_flags}

if [ X"${pf}" != X"NO" -a X"${pflogd_flags}" != X"NO" ]; then
	ifconfig pflog0 up
	pflogd ${pflogd_flags}
fi

# $named_flags, $named_user, and $named_chroot are imported from /etc/rc.conf;
# if $named_flags != NO, named is run.
if [ "X${named_flags}" != X"NO" ]; then
	if [ "X${named_user}" != "X" -a "X${named_user}" != X"root" ]; then
		named_flags="-u ${named_user} ${named_flags}"
	fi
	if [ "X${named_chroot}" != "X" ]; then
		if [ ! -c "${named_chroot}/dev/null" ]; then
			( cd /dev ; pax -rw -pe null ${named_chroot}/dev )
		fi
		if [ -f /etc/localtime -a -d "${named_chroot}/etc" ]; then
			cmp -s /etc/localtime "${named_chroot}/etc/localtime" \
			|| cp -p /etc/localtime "${named_chroot}/etc/localtime"
		fi
		named_flags="-t ${named_chroot} ${named_flags}"
	fi
	echo 'starting named';		named $named_flags
fi

# $photurisd_flags is imported from /etc/rc.conf;
# If $photurisd_flags == NO or /etc/photuris/photuris.conf doesn't exist, then
# photurisd isn't run.
if [ "X${photurisd_flags}" != X"NO" -a -e /etc/photuris/photuris.conf ]; then
	echo 'starting photurisd';	photurisd ${photurisd_flags}
fi

# $isakmpd_flags is imported from /etc/rc.conf;
# If $isakmpd_flags == NO or /etc/isakmpd/isakmpd.policy doesn't exist, then
# isakmpd isn't run.
if [ "X${isakmpd_flags}" != X"NO" -a -e /etc/isakmpd/isakmpd.policy ]; then
	echo 'starting isakmpd';	isakmpd ${isakmpd_flags}
fi

echo -n 'starting rpc daemons:'

# $portmap is imported from /etc/rc.conf;
# if $portmap == YES, the portmapper is started.
if [ X"${portmap}" = X"YES" ]; then
	echo -n ' portmap';		portmap
fi

if [ -d /var/yp/binding -a X`domainname` != X ]; then
	if [ -d /var/yp/`domainname` ]; then
		# yp server capabilities needed...
		echo -n ' ypserv';		ypserv ${ypserv_flags}
		#echo -n ' ypxfrd';		ypxfrd
	fi

	echo -n ' ypbind';		ypbind

	if [ -d /var/yp/`domainname` ]; then
		# if we are the master server, run rpc.yppasswdd
		_host1=`ypwhich -m passwd 2> /dev/null`
		_host2=`hostname`
		if [ `grep '^lookup' /etc/resolv.conf | grep yp | wc -c` -ne 0 ]; then
			_host1=`ypmatch $_host1 hosts | cut -d'	' -f2`
			_host2=`ypmatch $_host2 hosts | cut -d'	' -f2 | head -1`
		else
			_host1=`nslookup $_host1 | grep '^Name: ' | \
			    sed -e 's/^Name:    //'`
			_host2=`nslookup $_host2 | grep '^Name: ' | \
			    sed -e 's/^Name:    //'`
		fi
		if [ "$_host2" = "$_host1" ]; then
			echo -n ' rpc.yppasswdd'
			rpc.yppasswdd ${yppasswdd_flags}
		fi
	fi
fi

# $nfs_server is imported from /etc/rc.conf;
# if $nfs_server == YES, the machine is setup for being an nfs server
if [ X${nfs_server} = X"YES" -a -s /etc/exports -a \
    `sed -e '/^#/d' < /etc/exports | wc -l` -ne 0 ]; then
	rm -f /var/db/mountdtab
	echo -n > /var/db/mountdtab
	echo -n ' mountd';		mountd
	echo -n ' nfsd';		nfsd ${nfsd_flags}
	if [ X${lockd} = X"YES" ]; then
		echo -n ' rpc.lockd';	rpc.lockd
	fi
fi

if [ X${amd} = X"YES" -a -e ${amd_master} ]; then
	echo -n ' amd'
	(cd /etc/amd; amd -l syslog -x error,noinfo,nostats -p \
	    -a ${amd_dir} `cat ${amd_master}` > /var/run/amd.pid )
fi

# run rdate before timed
if [ X"${rdate_flags}" != X"NO" ]; then
        echo -n ' rdate';     rdate -s ${rdate_flags}
fi

# $timed_flags is imported from /etc/rc.conf;
# if $timed_flags == NO, timed isn't run.
if [ "X${timed_flags}" != X"NO" ]; then
	echo -n ' timed'; timed $timed_flags
fi
echo '.'

mount -a -t nfs

swapctl -A -t noblk

# /var/crash should be a directory or a symbolic link
# to the crash directory if core dumps are to be saved.
if [ -d /var/crash ]; then
	savecore ${savecore_flags} /var/crash
fi

if [ "X${afs}" = X"YES" -a -c ${afs_device} -a -d ${afs_mount_point} ]; then
	echo -n 'mounting afs:'
	mount -t xfs ${afs_device} ${afs_mount_point}
	/usr/libexec/afsd ${afsd_flags} -d ${afs_device}
	echo ' done.'
fi

if [ "X${check_quotas}" = X"YES" ]; then
	echo -n 'checking quotas:'
	quotacheck -a
	echo ' done.'
	quotaon -a
fi

# build ps databases
echo -n 'building ps databases:'
echo -n " kvm"
kvm_mkdb
echo -n " dev"
dev_mkdb
echo "."

chmod 666 /dev/tty[pqrstuvwxyzPQRST]*
chown root.wheel /dev/tty[pqrstuvwxyzPQRST]*

# check the password temp/lock file
if [ -f /etc/ptmp ]; then
	logger -s -p auth.err \
	'password file may be incorrect -- /etc/ptmp exists'
fi

echo clearing /tmp

# prune quickly with one rm, then use find to clean up /tmp/[lq]*
# (not needed with mfs /tmp, but doesn't hurt there...)
(cd /tmp && rm -rf [a-km-pr-zA-Z]* &&
    find . ! -name . ! -name lost+found ! -name quota.user \
	! -name quota.group -execdir rm -rf -- {} \; -type d -prune)

[ -f /etc/rc.securelevel ] && . /etc/rc.securelevel
if [ X${securelevel} != X"" ]; then
	echo -n 'setting kernel security level: '
	sysctl -w kern.securelevel=${securelevel}
fi

# patch /etc/motd
if [ ! -f /etc/motd ]; then
	install -c -o root -g wheel -m 664 /dev/null /etc/motd
fi
T=`mktemp /tmp/_motd.XXXXXXXXXX`
if [ $? -eq 0 ]; then
	sysctl -n kern.version | sed 1q > $T
	echo "" >> $T
	sed '1,/^$/d' < /etc/motd >> $T
	cmp -s $T /etc/motd || cp $T /etc/motd
	rm -f $T
fi

if [ -x /usr/libexec/vi.recover ]; then
	echo 'preserving editor files';	/usr/libexec/vi.recover
fi

if [ -f /var/account/acct ]; then
	echo 'turning on accounting';	accton /var/account/acct
fi

if [ -f /sbin/ldconfig ]; then
	echo 'creating runtime link editor directory cache.'
	if [ -d /usr/local/lib ]; then
		shlib_dirs="/usr/local/lib $shlib_dirs"
	fi
	if [ -d /usr/X11R6/lib ]; then
		shlib_dirs="/usr/X11R6/lib $shlib_dirs"
	fi
	ldconfig $shlib_dirs
fi

if [ ! -f /etc/ssh/ssh_host_dsa_key ]; then
	echo -n "ssh-keygen: generating new DSA host key... "
	if /usr/bin/ssh-keygen -q -t dsa -f /etc/ssh/ssh_host_dsa_key -N ''; then
		echo done.
	else
		echo failed.
	fi
fi
if [ ! -f /etc/ssh/ssh_host_rsa_key ]; then
	echo -n "ssh-keygen: generating new RSA host key... "
	if /usr/bin/ssh-keygen -q -t rsa -f /etc/ssh/ssh_host_rsa_key -N ''; then
		echo done.
	else
		echo failed.
	fi
fi
if [ ! -f /etc/ssh/ssh_host_key ]; then
	echo -n "ssh-keygen: generating new RSA1 host key... "
	if /usr/bin/ssh-keygen -q -t rsa1 -f /etc/ssh/ssh_host_key -N ''; then
		echo done.
	else
		echo failed.
	fi
fi

echo -n starting network daemons:

# $gated and $routed_flags are imported from /etc/rc.conf.
# If $gated == YES, gated is used; otherwise routed.
# If $routed_flags == NO, routed isn't run.
if [ X${gated} = X"YES" -a -e /etc/gated.conf ]; then
	echo -n ' gated';		/usr/local/sbin/gated $gated_flags
elif [ "X${routed_flags}" != X"NO" ]; then
	echo -n ' routed';		routed $routed_flags
fi

# $mrouted_flags is imported from /etc/rc.conf;
# If $mrouted_flags == NO, then mrouted isn't run.
if [ "X${mrouted_flags}" != X"NO" ]; then
	echo -n ' mrouted';		mrouted $mrouted_flags
fi

# $altqd_flags is imported from /etc/rc.conf;
# If $altqd_flags == NO, then altqd isn't run.
if [ "X${altqd_flags}" != X"NO" ]; then
	echo -n ' altqd';		altqd $altqd_flags
fi

# $dhcpd_flags is imported from /etc/rc.conf
# If $dhcpd_flags == NO or /etc/dhcpd.conf doesn't exist, then dhcpd isn't run.
if [ "X${dhcpd_flags}" != X"NO" -a -f /etc/dhcpd.conf ]; then
	touch /var/db/dhcpd.leases
	if [ -f /etc/dhcpd.interfaces ]; then
		dhcpd_ifs=`awk -F\# '{ print $1; }' < /etc/dhcpd.interfaces`
	fi
	echo -n ' dhcpd';	/usr/sbin/dhcpd ${dhcpd_flags} ${dhcpd_ifs}
fi

if ifconfig lo0 inet6 >/dev/null 2>&1; then
	fw=`sysctl -n net.inet6.ip6.forwarding`
	if [ "X${fw}" == X"0" ]; then
		# $rtsold_flags is imported from /etc/rc.conf;
		# If $rtsold_flags == NO, then rtsold isn't run.
		if [ "X${rtsold_flags}" != X"NO" ]; then
			echo -n ' rtsold'
			/usr/sbin/rtsold ${rtsold_flags}
		fi
	else
		# $route6d_flags is imported from /etc/rc.conf;
		# If $route6d_flags == NO, then route6d isn't run.
		if [ "X${route6d_flags}" != X"NO" ]; then
			echo -n ' route6d'
			/usr/sbin/route6d ${route6d_flags}
		fi
		# $rtadvd_flags is imported from /etc/rc.conf;
		# If $rtadvd_flags == NO, then rtadvd isn't run.
		if [ "X${rtadvd_flags}" != X"NO" ]; then
			echo -n ' rtadvd'
			/usr/sbin/rtadvd ${rtadvd_flags}
		fi
	fi
fi

# $rwhod is imported from /etc/rc.conf;
# if $rwhod == YES, rwhod is run.
if [ X${rwhod} = X"YES" ]; then
	echo -n ' rwhod';		rwhod
fi


if [ X${lpd_flags} != X"NO" ]; then
	echo -n ' printer';		lpd ${lpd_flags}
fi

# $sendmail_flags is imported from /etc/rc.conf;
# If $sendmail_flags == NO or /etc/mailer.conf doesn't exist, then
# sendmail isn't run.  We call sendmail with a full path so that
# SIGHUP works.  Note that /usr/sbin/sendmail may actually call a
# mailer other than sendmail, depending on /etc/mailer.conf.
if [ "X${sendmail_flags}" != X"NO" -a -s /etc/mailer.conf ]; then
	echo -n ' sendmail';		( /usr/sbin/sendmail ${sendmail_flags} >/dev/null 2>&1 & )
fi

if [ "X${httpd_flags}" != X"NO"  ]; then
	# Clean up left-over httpd locks
	rm -f /var/www/logs/{ssl_mutex,httpd.lock,accept.lock}.*
	echo -n ' httpd';		/usr/sbin/httpd ${httpd_flags}
fi

if [ "X${ftpd_flags}" != X"NO" ]; then
	echo -n ' ftpd';		/usr/libexec/ftpd ${ftpd_flags}
fi

if [ "X${identd_flags}" != X"NO" ]; then
	echo -n ' identd';		/usr/libexec/identd ${identd_flags}
fi

# $smtpfwdd_flags is imported from /etc/rc.conf;
# If $smtpfwdd_flags == NO, smtpfwdd isn't run.
if [ "X${smtpfwdd_flags}" != X"NO" ]; then
	echo -n ' smtpfwdd';	/usr/libexec/smtpfwdd ${smtpfwdd_flags}
fi


if [ X${inetd} = X"YES" -a -e /etc/inetd.conf ]; then
	echo -n ' inetd';		inetd
fi

# $rarpd_flags is imported from /etc/rc.conf;
# If $rarpd_flags == NO or /etc/ethers doesn't exist, then
# rarpd isn't run.
if [ "X${rarpd_flags}" != X"NO" -a -s /etc/ethers ]; then
	echo -n ' rarpd';		rarpd ${rarpd_flags}
fi

# $bootparamd_flags is imported from /etc/rc.conf;
# If $bootparamd_flags == NO or /etc/bootparams doesn't exist, then
# bootparamd isn't run.
if [ "X${bootparamd_flags}" != X"NO" -a -s /etc/bootparams ]; then
	echo -n ' rpc.bootparamd';	rpc.bootparamd ${bootparamd_flags}
fi

# $rbootd_flags is imported from /etc/rc.conf;
# If $rbootd_flags == NO or /etc/rbootd.conf doesn't exist, then
# rbootd isn't run.
if [ "X${rbootd_flags}" != X"NO" -a -s /etc/rbootd.conf ]; then
	echo -n ' rbootd';		rbootd ${rbootd_flags}
fi

# $mopd_flags is imported from /etc/rc.conf;
# If $mopd_flags == NO or /tftpboot/mop doesn't exist, then
# mopd isn't run.
if [ "X${mopd_flags}" != X"NO" -a -d /tftpboot/mop ]; then
	echo -n ' mopd';		mopd ${mopd_flags}
fi

if [ X"${sshd_flags}" != X"NO" ]; then
	/usr/sbin/sshd ${sshd_flags};	echo -n ' sshd'
fi

echo '.'

if [ -f /etc/wsconsctl.conf ]; then
(
	# delete comments and blank lines
	set -- `stripcom /etc/wsconsctl.conf`
	while [ $# -ge 1 ] ; do
		wsconsctl -w $1
		shift
	done
)
fi

if [ -f /sbin/kbd -a -f /etc/kbdtype ]; then
	kbd `cat /etc/kbdtype`
fi

# KerberosIV runs ONLY on the KDC servers
# Kadmin runs only on the master server
if [ X${krb4_master_kdc} = X"YES" ]; then
	echo 'KerberosIV KDC'
	/usr/libexec/kerberos >> /var/log/kerberos.log &
	/usr/libexec/kadmind -n >> /var/log/kadmind.log &
fi

# Kpropd runs only on Kerberos slave servers
if [ X${krb4_slave_kdc} = X"YES" ]; then
	echo 'kerberos slave server'
	/usr/libexec/kerberos -s >> /var/log/kerberos.log &
	/usr/libexec/kpropd -i &
fi

# KerberosV master KDC
if [ X${krb5_master_kdc} = X"YES" ]; then
	echo 'KerberosV master KDC'
	/usr/libexec/kdc &
	/usr/libexec/kadmind &
	/usr/libexec/kpasswdd &
fi

# KerberosV slave KDC
if [ X${krb5_slave_kdc} = X"YES" ]; then
	echo 'KerberosV slave KDC'
	/usr/libexec/kdc &
	# Remember to enable hpropd in inetd.conf
fi

[ -f /etc/rc.local ] && . /etc/rc.local

echo -n standard daemons:

# $apmd_flags is imported from /etc/rc.conf;
# don't run daemon if $apmd_flags == NO or /usr/sbin/apmd doesn't exist
if [ "X${apmd_flags}" != X"NO" -a -x /usr/sbin/apmd ]; then
        echo -n ' apmd';        /usr/sbin/apmd ${apmd_flags}
fi

if [ -x /usr/sbin/screenblank ]; then
	echo -n ' screenblank';	/usr/sbin/screenblank
fi

echo -n ' cron';		cron

echo '.'

date

if [ "X${wsmoused_flags}" != X"NO" -a -x /usr/sbin/wsmoused ]; then
	echo 'starting wsmoused...';	/usr/sbin/wsmoused ${wsmoused_flags}
fi

# Alternatively, on some architectures, xdm may be started in /etc/ttys.
if [ "X${xdm_flags}" != X"NO" ]; then
	echo 'starting xdm...';		/usr/X11R6/bin/xdm ${xdm_flags}
fi

exit 0

